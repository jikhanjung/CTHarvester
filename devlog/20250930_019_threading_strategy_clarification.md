# 스레드 전략 명확화

날짜: 2025-09-30
작성자: Strategy Clarification

## 실제 상황

### 잘못된 가정 ❌
- "단일 스레드가 멀티스레드보다 빠르다"
- "항상 9-10분 vs 30-40분"

### 실제 상황 ✅
- **멀티스레드가 보통은 더 빠름**
- **하지만 예측 불가능한 병목 발생**
  - 대부분 이미지: 정상 처리
  - 일부 이미지: 갑자기 10-20초 걸림 (락 경합)
- **불안정한 성능이 문제**

## 왜 단일 스레드를 선택했나?

### 핵심 이유

1. **예측 가능성 > 평균 성능**
   - 멀티스레드: 빠르지만 간헐적으로 매우 느림
   - 단일 스레드: 느리지만 일정함
   - 사용자 경험: 예측 가능한 것이 중요

2. **Python은 백업 구현**
   - 주력: Rust 모듈 (2-3분, 진짜 빠름)
   - 보조: Python 폴백 (Rust 없을 때만)
   - Python 성능 최적화는 우선순위 낮음

3. **디버깅 용이성**
   - 멀티스레드 버그: 재현 어려움
   - 단일 스레드: 문제 추적 쉬움
   - 백업 구현은 단순함이 중요

## 성능 프로필

### 멀티스레드 (불안정)
```
일반 이미지:  100-200ms  ✓
일반 이미지:  150-250ms  ✓
일반 이미지:  120-180ms  ✓
문제 이미지:  10000ms    ✗  (락 경합)
일반 이미지:  110-190ms  ✓
일반 이미지:  140-220ms  ✓
문제 이미지:  15000ms    ✗  (PIL 락?)
...

평균: 빠름
최악: 매우 느림
예측: 불가능
```

### 단일 스레드 (안정)
```
모든 이미지:  180-200ms  ✓
모든 이미지:  180-200ms  ✓
모든 이미지:  180-200ms  ✓
모든 이미지:  180-200ms  ✓

평균: 보통
최악: 보통
예측: 가능
```

## 트레이드오프 분석

| 측면 | 멀티스레드 | 단일 스레드 |
|------|-----------|------------|
| **평균 성능** | 빠름 | 보통 |
| **최악 성능** | 매우 느림 | 보통 |
| **예측 가능성** | 낮음 | 높음 |
| **디버깅** | 어려움 | 쉬움 |
| **코드 복잡도** | 높음 | 낮음 |
| **사용자 경험** | 나쁨 (가끔 멈춤) | 좋음 (일정) |

## 올바른 관점

### Python 폴백의 역할

```
사용자가 Rust 모듈 설치 실패한 경우:
├─ 옵션 1: 아예 기능 안 됨 (최악)
├─ 옵션 2: Python으로라도 작동 (백업)
└─ 목표: "그냥 돌아가게" 하는 것

Python 폴백 요구사항:
✓ 기능적으로 완전함
✓ 안정적으로 작동
✓ 코드 단순함
✗ 성능 최적화는 Nice-to-have
```

### 실용적 결정

**멀티스레드가 이론적으로 빠르더라도**:
- 간헐적 10-20초 멈춤 → 사용자: "프로그램 버그인가?"
- 디버깅 어려움 → 유지보수 비용 증가
- 복잡한 코드 → 다른 버그 가능성

**단일 스레드 선택**:
- 항상 일정한 속도 → 사용자: "진행되고 있구나"
- 문제 발생 시 추적 쉬움
- 코드 단순 → 다른 개선에 집중 가능

## 코드 수정 제안

### 현재 코드의 문제

```python
def _determine_optimal_thread_count(self):
    """
    Python의 GIL과 디스크 I/O 특성상 단일 스레드가 최적

    멀티스레드 성능 저하 원인:
    1. GIL로 인한 CPU-bound 작업 직렬화
    2. 디스크 I/O 경합 (Seek time 10-100배 증가)
    3. PIL 내부 락 대기 (10-20초)

    측정 결과:
    - 단일 스레드: 9-10분
    - 멀티 스레드: 30-40분 (3-4배 느림!)
    """
    return 1
```

**문제점**:
- "멀티스레드가 항상 느림"이라고 오해하게 만듦
- 실제로는 "불안정함"이 문제

### 개선된 코드

```python
def _determine_optimal_thread_count(self):
    """
    Python 폴백에서 단일 스레드를 사용하는 이유

    [배경]
    Python 구현은 Rust 모듈의 백업입니다.
    - 주력: Rust 모듈 (2-3분, 진정한 멀티스레드)
    - 보조: Python 폴백 (Rust 설치 실패 시)

    [멀티스레드 문제]
    평균적으로는 더 빠르지만, 예측 불가능한 병목이 발생:
    - 대부분 이미지: 100-200ms (정상)
    - 일부 이미지: 10-20초 (락 경합, PIL 내부 문제)
    - 원인: GIL 경합, 디스크 I/O 경합, PIL/NumPy 내부 락

    [단일 스레드 선택 이유]
    1. 예측 가능성: 모든 이미지가 일정한 속도 (180-200ms)
    2. 안정성: 간헐적 멈춤 현상 없음
    3. 디버깅 용이성: 문제 추적 쉬움
    4. 코드 단순성: 백업 구현은 단순함 우선
    5. 사용자 경험: 느리지만 일정 > 빠르지만 가끔 멈춤

    [성능 비교]
    - 단일 스레드: 안정적으로 9-10분
    - 멀티 스레드: 평균 6-7분, 최악 30-40분 (일부 이미지에서)

    백업 구현의 목표는 "최고 성능"이 아니라 "안정적 작동"입니다.

    Returns:
        int: 1 (단일 스레드, 안정성과 예측 가능성 우선)
    """
    import logging
    logger = logging.getLogger('CTHarvester')

    logger.info(
        "Python fallback: Using single thread for stability "
        "(Rust module is the primary high-performance solution)"
    )

    return 1
```

## 아키텍처 관점

### 2-Tier 전략

```
┌─────────────────────────────────────┐
│   Tier 1: Rust 모듈 (Primary)      │
│   - 진정한 멀티스레드               │
│   - 2-3분 (3000 이미지)            │
│   - GIL 없음, 최적화된 I/O         │
│   - 목표: 최고 성능                 │
└─────────────────────────────────────┘
              ↓ (설치 실패 시)
┌─────────────────────────────────────┐
│   Tier 2: Python 폴백 (Backup)     │
│   - 단일 스레드                     │
│   - 9-10분 (3000 이미지)           │
│   - 안정적, 예측 가능               │
│   - 목표: "그냥 돌아가게"           │
└─────────────────────────────────────┘
```

### 각 구현의 설계 목표

**Rust 모듈**:
- ✓ 최고 성능
- ✓ 멀티코어 완전 활용
- ✓ 최적화된 I/O

**Python 폴백**:
- ✓ 기능 완전성
- ✓ 안정성
- ✓ 단순성
- ✗ 성능 최적화 (Nice-to-have, 필수 아님)

## 결론

### 핵심 깨달음

1. **"빠르다" != "좋다"**
   - 예측 불가능한 빠름 < 예측 가능한 보통

2. **컨텍스트가 중요**
   - 주력 구현: 성능 최적화 필수
   - 백업 구현: 안정성 우선

3. **사용자 경험 우선**
   - 평균 7분, 가끔 40분 (나쁨)
   - 일정한 10분 (좋음)

4. **실용주의**
   - Python 멀티스레드 디버깅에 시간 쓰느니
   - Rust 모듈 개선에 시간 쓰는 게 나음

### 최종 선택

**단일 스레드 유지**:
- ✓ 안정성
- ✓ 예측 가능성
- ✓ 디버깅 용이성
- ✓ 코드 단순성
- ✗ 평균 성능 (어차피 백업이라 OK)

이것이 **백업 구현의 올바른 철학**입니다.